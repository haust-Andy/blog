---
title: C++知识点
tags: C++
categories: C++
---

# 1.C++的内存分区
●可分为四大内存分区：堆、栈、全局/静态存储区和代码区
●堆区：由编程人员手动申请，手动释放，若不手动释放，程序结束后由系统回收，生命周期是整个程序运行期间。使用malloc或者new进行堆的申请，堆的总大小为机器的虚拟内存的大小 。
●new和malloc的区别。new操作符本质上是使用了malloc进行内存的申请，new和malloc的区别如下：
●（1）malloc是C语言中的函数，而new是C++中的操作符。
●（2）malloc申请之后返回的类型是void*，而new返回的指针带有类型。
●（3）malloc只负责内存的分配而不会调用类的构造函数，而new不仅会分配内存，而且会自动调用类的构造函数。
●栈区：由系统进行内存的管理。主要存放函数的参数以及局部变量。在函数完成执行，系统自行释放栈区内存，不需要用户管理。整个程序的栈区的大小可以在编译器中由用户自行设定，VS中默认的栈区大小为1M，可通过VS手动更改栈的大小。64bits的Linux默认栈大小为10MB，可通过ulimit -s临时修改。
●全局/静态存储区：全局/静态存储区内的变量在程序编译阶段已经分配好内存空间并初始化。这块内存在程序的整个运行期间都存在，它主要存放静态变量、全局变量和常量。
●代码区：存放程序体的二进制代码。比如我们写的函数，都是在代码区的。
# 2.this指针
●this 是 C++ 中的一个关键字，也是一个 const 指针，它指向当前对象，通过它可以访问当前对象的所有成员。
●this 只能用在类的内部，通过 this 可以访问类的所有成员，包括 private、protected、public 属性的。
●this 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 this 赋值。本例中，this 的值和 pstu 的值是相同的。
●this 实际上是成员函数的一个形参，在调用成员函数时将对象的地址作为实参传递给 this。不过 this 这个形参是隐式的，它并不出现在代码中，而是在编译阶段由编译器默默地将它添加到参数列表中。
●this 作为隐式形参，本质上是成员函数的局部变量，所以只能用在成员函数的内部，并且只有在通过对象调用成员函数时才给 this 赋值。
# 3.哪些函数不能是虚函数  构造函数和析构函数能不能是虚函数 为什么？
●虚函数的作用是实现动态绑定的，也就是说程序在运行的时候动态的的选择合适的成员函数，拥有 Virtual 关键字的函数称之为虚函数。虚函数的作用是实现动态绑定的，也就是说程序在运行的时候动态的的选择合适的成员函数。
●要成为虚函数必须满足两点，
●一就是这个函数依赖于对象调用，因为虚函数就是依赖于对象调用，因为虚函数是存在于虚函数表中，有一个虚函数指针指向这个虚表，所以要调用虚函数，必须通过虚函数指针，而虚函数指针是存在于对象中的。
●二就是这个函数必须可以取地址，因为我们的虚函数表中存放的是虚函数函数入口地址，如果函数不能寻址，就不能成为虚函数。
●哪些函数不能成为虚函数？
●1.内联函数：我们都知道内联函数只是在函数调用点将其展开，它不能产生函数符号，所以不能往虚表中存放，自然就不能成为虚函数。
●2.静态函数：定义为静态函数的函数，这个函数只和类有关系，它不完全依赖于对象调用，所以也不能成为虚函数。
●3.构造函数：都知道只有当调用了构造函数，这个对象才能产生，如果把构造函数写成虚函数，这时候我们的对象就没有办法生    成。更别说用对象去调用了。所以构造函数不能成为虚函数。
●4.友元函数：友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。
●5.普通函数：普通函数不属于成员函数，是不能被继承的。普通函数只能被重载，不能被重写，因此声明为虚函数没有意义。因为编译器会在编译时绑定函数。
●哪些函数可以成为虚函数？
●1.普通的成员方法是可以成为虚函数的
●2.还有析构函数，因为析构函数是为了释放对象的，所以之前我们的对象已经生成，而且析构函数可以取地址，所以可以成为虚函数
●什么情况下，析构函数必须定义为虚函数。
●为了释放掉堆上的派生类对象
●如果基类的析构函数没有写成虚函数，delete这个基类指针，就不能释放掉堆上的派生类对象。因为delete p会调用基类的析构，你觉得调用基类的析构函数会释放掉派生类的对象吗？当然是不可能的。所以我们就要把基类的析构函数写成虚函数。写成虚函数后，当delete的时候，先会去基类调用析构函数，一看基类的析构函数是虚函数，就会自动的到派生类中调用派生类的析构函数。这时候派生类的对象就能释放了。
# 4.常见的智能指针
●auto_ptr（c++17废除）
●由new expression获得对象，它假设我们的对象是在栈空间中创建，所以在auto_ptr对象销毁时（auto_ptr跳出作用域），他所管理的对象也会被自动delete掉。所有权转移：当我们用auto_ptr指向一个对象，而不小心用另一个auto_ptr指向同一个对象，那么这个时候原来的auto_ptr就会失效，不再拥有这个对象，而是指向nullptr。这是在拷贝/赋值的过程中把指针对原对象的内存控制权剥夺的。所以这让我们很难管理程序，会造成混乱。
●unique_ptr
●unique_ptr是专属所有权，所以unique_ptr管理的内存，只能被一个对象持有，不支持赋值和复制。
●移动语义：unique_ptr禁止了拷贝语义，但是有时候我们也会需要能够转移所有权，于是提供了移动语义，即可以使用std::move()进行控制所有权地方转移。
●shared_ptr
●shared_ptr通过一个引用计数共享一个对象。它是为了解决auto_ptr在对象所有权上的局限性。在使用引用计数的机制上提供了可以共享所有权的智能指针，当然这需要额外的开销。
●当引用计数为0 时，该对象没有被使用，可以进行析构。
●引用计数也会带来一些副作用，比如循环引用的问题，导致堆内的内存无法正常回收，造成内存泄漏。如下图，有A和B两个对象，各含有一个shared_ptr pA和pB。某一时刻pA指向的对象是pB，而pB指向的对象是pA。当A对象想要释放自己的时候，由于释放自己要释放自己内部的所有内容，因为内部智能指针指向B，那么就需要释放B，而B要释放就要释放pB指向的A对象，这样就形成了一个环结构，相互指向无法释放。
●weak_ptr
●weak_ptr被设计与shared_ptr共同工作，用一种观察者模式工作。它协助shared_ptr工作，可获得资源的观测权，像旁观者那样观测资源的使用情况。观察者意味着weak_ptr只对shared_ptr进行引用，而不改变其引用计数，当被观察的shared_ptr失效后，相应的weak_ptr也失效。
# 5.C++中重载、重写(覆盖)和（重定义）隐藏的区别
●重载：是指同一可访问区内被声明的几个具有不同参数列（参数的类型，个数，顺序不同）的同名函数，根据参数列表确定调用哪个函数，重载不关心函数返回类型。
●隐藏：是指派生类的函数屏蔽了与其同名的基类函数，注意只要同名函数，不管参数列表是否相同，基类函数都会被隐藏。
●重载和重写的区别：
●（1）范围区别：重写和被重写的函数在不同的类中，重载和被重载的函数在同一类中。
●（2）参数区别：重写与被重写的函数参数列表一定相同，重载和被重载的函数参数列表一定不同。
●（3）virtual的区别：重写的基类必须要有virtual修饰，重载函数和被重载函数可以被virtual修饰，也可以没有。
●隐藏和重写，重载的区别：
●（1）与重载范围不同：隐藏函数和被隐藏函数在不同类中。
●（2）参数的区别：隐藏函数和被隐藏函数参数列表可以相同，也可以不同，但函数名一定同；当参数不同时，无论基类中的函数是否被virtual修饰，基类函数都是被隐藏，而不是被重写。 
●

●C++中重载、重写（覆盖）和隐藏的区别 - 头文件1991 - 博客园 (cnblogs.com)
# 6.C++有哪几种的构造函数,什么情况下会调用拷贝构造函数 
●默认构造函数：未提供显式初始值时，用来创建对象的构造函数
●当一个类没有构造函数时，如果满足以下四个条件其中之一，则编译器会为该类自动生成一个默认的构造函数：1.该类含有一个类类型（非内置类型）的成员变量，且该类型含有默认构造函数。2.该类继承自含有默认构造函数的基类。3.该类继承或声明了虚函数。4.该类含有虚基类。
●普通构造函数：C++用于构建类的新对象时需要调用的函数
●拷贝构造函数：
●当一个类没有拷贝构造函数时，如果满足以下四个条件其中之一，则编译器会为该类自动生成一个默认的拷贝构造函数。1.该类含有一个类类型（非内置类型）的成员变量，且该类型含有拷贝构造函数。2.该类继承自含有拷贝构造函数的基类。3.该类继承或声明了虚函数。4.该类含有虚基类。
●默认的拷贝构造函数实现的是浅拷贝。
●拷贝构造函数调用的时机：拷贝构造函数在以下三种情况下会被调用。
●(1).当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。例如，下面的两条语句都会引发复制构造函数的调用，用以初始化 c2。第二条语句是初始化语句，不是赋值语句。赋值语句的等号左边是一个早已有定义的变量，赋值语句不会引发复制构造函数的调用。

●(2)如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的类A的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。

●这是因为 Func 函数的形参 a 在初始化时调用了复制构造函数。
●前面说过，函数的形参的值等于函数调用时对应的实参，现在可以知道这不一定是正确的。如果形参是一个对象，那么形参的值是否等于实参，取决于该对象所属的类的复制构造函数是如何实现的。例如上面的例子，Func 函数的形参 a 的值在进入函数时是随机的，未必等于实参，因为复制构造函数没有做复制的工作。
●以对象作为函数的形参，在函数被调用时，生成的形参要用复制构造函数初始化，这会带来时间上的开销。如果用对象的引用而不是对象作为形参，就没有这个问题了。但是以引用作为形参有一定的风险，因为这种情况下如果形参的值发生改变，实参的值也会跟着改变。
●如果要确保实参的值不会改变，又希望避免复制构造函数带来的开销，解决办法就是将形参声明为对象的 const 引用。例如：void Function(const Complex & c)
●3). 如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化 的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。例如下面的程序：

●转换构造函数：一个构造函数接收一个不同于其类类型的形参，可以视为将其形参转换成类的一个对象。像这样的构造函数称为转换构造函数。在 C++ string 类中可以找到使用转换构造函数的实用示例。
●移动构造函数：所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。

●当类的对象需要拷贝时，拷贝构造函数将会被调用。以下情况都会调用拷贝构造函数：
●一个对象以值传递的方式传入函数体
●一个对象以值传递的方式从函数返回
●一个对象需要通过另外一个对象进行初始化
●(35条消息) C++中的五种构造函数_c++有几种构造函数_TABE_的博客-CSDN博客
# 7.值传递、指针传递、引用传递的区别和效率
●1) 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象 或是大的结构体对象，将耗费一定的时间和空间。（传值）
●2) 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为4字节的地址。（传值，传递的是地址值）
●3) 引用传递：同样有上述的数据拷贝过程，但其是针对地址的，相当于为该数据所在的地址起了一个别名。（传地址）
●4) 效率上讲，指针传递和引用传递比值传递效率高。一般主张使用引用传递，代码逻辑上更加紧凑、清晰。
# 8.动态多态和静态多态
●静态多态：也成为编译时的多态；在编译时期就已经确定要执行了的函数地址了；主要有函数重载和函数模板（这里只写函数重载）/根据目标对象的静态类型和参数表中的静态类型确定目标代码体
●（1）重写基类函数（方法）
●模板-不同的模板参数
●函数重载
●动态多态：即动态绑定，在运行时才去确定对象类型和正确选择需要调用的函数，一般用于解决基类指针或引用派生类对象调用类中重写的方法（函数）时出现的问题/即运行时的多态，在程序执行期间(非编译期)判断所引用对象的实际类型，根据其实际类型调用相应的方法
●动态多态：
●根据目标对象的动态类型和参数表中的静态类型确定目标代码体（虚机制）
●根据目标对象的动态类型和参数表中的动态类型确定目标代码体（c++不支持）
●静态类型：对象声明时的类型，编译时确定
●动态类型：目前所指对象的类型，运行时确定
# 9.动态绑定和静态绑定
●静态类型与动态类型
●对象的静态类型：对象在声明时候的类型，是在编译时期确定的。
●对象的动态类型：目标所指向的对象，是在运行期决定的。对象的动态类型可以更改，但是静态类型无法更改。
●静态绑定与动态绑定
●静态绑定：绑定的是静态类型，比如函数依赖于对象的静态类型，发生在编译期。
●动态绑定：绑定的是动态类型，比如函数依赖于对象的动态类型，发生在运行期。
●

●(1) 和 (2) 调用的是不同的函数。
●因为DoSomething函数不是虚函数，是静态绑定的，在编译器时期会根据对象的类型选择函数。
●pD的静态类型是D*，pB的静态类型是B*。所以（1）调用的是D::DoSomething()；（2）调用的是B::DoSmething()。
●（3）和（4）调用的是相同的函数。
●因为vfun函数是虚函数，是动态绑定的，绑定的是对象的动态类型。
●pB虽然和pD的静态类型不同，但是他们指向同一个对象，动态类型是相同的，都是D*。所以调用的都是D::vfun()。
●只有虚函数才有动态绑定，其他的都是静态绑定。
# 10.空类的大小是多少
●(35条消息) C++的空类大小及带虚函数的空类大小_c++虚函数大小_德胜coding的博客-CSDN博客
●空类的大小是1个字节
●C++标准规定类的不同实例化对象应该是不同的地址
●编译器会给一个空类或者空的结构体中加入一个最小字节（1字节）作为区分。为什么是一个字节而不是四个字节或者更多的字节，这是编译器规定的，既然一个字节就可以达到区分实例对象的地址之目的，那显然没必要设置更大的空间造成浪费。
●类的大小计算的时候，只包括：
●1 类的非静态成员数据的类型大小之和．
●2 如果有虚函数的话，还要加上指向虚函数的指针（vptr）大小
●3 边缘调整后的大小
●4 与类中的构造函数，析构函数以及其他的成员函数无关．
●对象调用成员函数时，编译器可以确定这些函数的地址，并通过传入this指针和其他参数，完成函数的调用，所以类中就没有必要存储成员函数的信息，也就是说成员函数会绑定到this指针
●
# 11.函数指针
●函数指针是指向函数的指针变量。 因此“函数指针”本身首先应是指针变量，只不过该指针变量指向函数。这正如用指针变量可指向整型变量、字符型、数组一样，这里是指向函数。如前所述，C在编译时，每一个函数都有一个入口地址，该入口地址就是函数指针所指向的地址。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型变量一样，在这些概念上是大体一致的。函数指针有两个用途：调用函数和做函数的参数。
●万字长文系统梳理一下C++函数指针 - 知乎 (zhihu.com)
●
# 12.内存泄漏是什么  怎么解决
●C/C++内存泄漏-原因、避免以及定位 - 知乎 (zhihu.com)
●程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。当我们在程序中对原始指针(raw pointer)使用new操作符或者free函数的时候，实际上是在堆上为其分配内存，这个内存指的是RAM，而不是硬盘等永久存储。持续申请而不释放(或者少量释放)内存的应用程序，最终因内存耗尽导致OOM(out of memory)
●内存泄漏，主要指的是在堆(heap)上申请的动态内存泄漏，或者说是指针指向的内存块忘了被释放，导致该块内存不能再被申请重新使用。
●以产生的方式来分类，内存泄漏可以分为四类:
●常发性内存泄漏：产生内存泄漏的代码或者函数会被多次执行到，在每次执行的时候，都会产生内存泄漏。
●偶发性内存泄漏：与常发性内存泄漏不同的是，偶发性内存泄漏函数只在特定的场景下才会被执行。
●一次性内存泄漏：这种内存泄漏在程序的生命周期内只会泄漏一次，或者说造成泄漏的代码只会被执行一次。
●隐式内存泄漏：程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。
●避免
●避免在堆上分配：众所周知，大部分的内存泄漏都是因为在堆上分配引起的，如果我们不在堆上进行分配，就不会存在内存泄漏了(这不废话嘛)，我们可以根据具体的使用场景，如果对象可以在栈上进行分配，就在栈上进行分配，一方面栈的效率远高于堆，另一方面，还能避免内存泄漏，我们何乐而不为呢。
●手动释放：对于malloc函数分配的内存，在结束使用的时候，使用free函数进行释放；对于new操作符创建的对象，切记使用delete来进行释放；对于new []创建的对象，使用delete[]来进行释放(使用free或者delete均会造成内存泄漏)
●避免使用裸指针：尽可能避免使用裸指针，除非所调用的lib库或者合作部门的接口是裸指针。
●使用STL中或者自己实现对象：
●在C++中，提供了相对完善且可靠的STL供我们使用，所以能用STL的尽可能的避免使用C中的编程方式，比如：
●使用std::string 替代char *, string类自己会进行内存管理，而且优化的相当不错
●使用std::vector或者std::array来替代传统的数组
●其它适合使用场景的对象
●智能指针
# 13.浅拷贝和深拷贝的区别
●C++深拷贝与浅拷贝 - as_ - 博客园 (cnblogs.com)
●位拷贝又称浅拷贝
●在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B。这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。
●深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。
●自定义拷贝构造函数是一种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率。
# 14.结构体和class的区别
●C++ class和struct到底有什么区别 (biancheng.net)
●在C语言中，struct 只能包含成员变量，不能包含成员函数。而在C++中，struct 类似于 class，既可以包含成员变量，又可以包含成员函数。
●使用 class 时，类中的成员默认都是 private 属性的；而使用 struct 时，结构体中的成员默认都是 public 属性的。
●class 继承默认是 private 继承，而 struct 继承默认是 public 继承。
●class 可以使用模板，而 struct 不能




